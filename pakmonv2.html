<!DOCTYPE html>
<html>

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Draws grid with walls and coins on canvas</title>

  <style>
    body {
        background-color: black;
    }
    canvas {
        border: 1px solid white;
        margin: 45px;
    }
  </style>

  
</head>
<body>
    <canvas id="canvas" width="300" height="250">
        This text is displayed if your browser does not support HTML5 Canvas.
    </canvas>

    <script>

const my_canvas = document.getElementById("canvas")
const ctx = my_canvas.getContext("2d")

const levels = { // arr idx works as a cell number, arr contains open passages
    columns: 6,
    rows: 5,
    1: [[6,1],[0,7,2],[1,3],[2,9],[10,5],[4],[0,12],[1,8,13],[9,7],[3,8,10],[11,9,4],[17,10],[18,6],[7,14],[13,20,15],[21,14],[17,22],[16,11,23],[19,12,24],[20,18],[14,19],[27,15,22],[21,16],[17,29],[18,25],[24,26],[25,27],[26,21,28],[27],[23]],
    2: [[1,6],[2,0],[8,3,1],[2,4],[3,10,5],[4],[0,12],[],[14,2],[],[16,4],[17],[6,13,18],[14,12,19],[15,8,13],[16,14,21],[15,10,17],[16,11,23],[12,24],[13,25],[],[27,15],[],[17,29],[18],[19,26],[25,27],[28,21,26],[29,27],[23,28]], 
    3: [[6],[2,7],[3,1],[2,4],[5,3],[11,4],[0,12],[1,13],[9,14],[10,8],[16,9],[17,5],[6,18],[7,19],[8,15],[14,16],[22,10,15],[23,11],[12,24],[13,20],[19,21],[20,22],[21,16],[29,17],[18,25],[24,26],[25,27],[28,26],[27,29],[28,23]], 
    4: [[1,6],[0,2,7],[8,1],[9,4],[5,3],[4,11],[0],[13,1],[2,9],[8,3],[16],[5,17],[13,18],[14,7,19,12],[13,20],[16],[15,10,22,17],[11,16],[24,12],[13],[21,26,14],[27,20],[16],[29],[18,25],[24,26],[20,25],[21,28],[29,27],[23,28]], 
    5: [[1,6],[2,0],[3,1],[9,2],[10,5],[4],[0,7],[6,13],[14,9],[10,3,8],[11,4,9],[17,10],[13,18],[7,12],[8,15],[14,21],[22,17],[16,11],[12,19,24],[18,20],[19,21,26],[20,15],[23,16],[22,29],[18,25],[24],[27,20],[28,26],[29,27],[23,28]], 
    6: [[6,1],[0,2],[1,3],[2,9,4],[3,5],[4,11],[0,12],[8,13],[9,7,14],[3,8,10,15],[9,16],[5,17],[13,6,18],[7,12,19],[20,8],[9],[17,10,22],[11,16,23],[12,24],[20,13],[21,19,14],[27,20,22],[16,21],[17,29],[18,25],[24,26],[25,27],[26,21,28],[29,27],[23,28]]
}

const gameState = {
    level: 0,
    coinsGrid: [], // coins use bigger grid to represent cells and passages between
    pathFinding: [], // distance from a player, idx: distance
    
    player: {
        pos: [0, 0], // cellwise [x, y]
        targetPos: [0, 0], // moving right 
        offset: [0, 0], // offset from the cell || + 12 x, + 15 y for good looking
        cellIdx: 0,
        targetCellIdx: 0,
        currentDirection: "",
    },
    
    ghostPos: [3, 1],
    erorrGhostPos: [4, 1],
    keyPressed: "",
}

const assets = {
    ghost: (() => {
        const ghost = new Image()
        ghost.src = "duch.png"
        return ghost
    })(),
    ghostError: (() => {
        const ghostError = new Image()
        ghostError.src = "duchy.png"
        return ghostError
    })(),
    player: (() => {
        const player = new Image()
        player.src = "pakmon3.png"
        return player
    })(),
}

function promiseAssets(image) {
    return new Promise(resolve => {
        image.onload = () => setTimeout(() => {console.log("testing delay", image); resolve()}, 100)
        // image.onload = () => resolve()
        image.onerror = () => {image.src = "error.png"; resolve()}
        // image.onerror = () => resolve()
    })
}

Promise.all([assets.ghost, assets.player, assets.ghostError].map(promiseAssets)).then(() => test())

function test() {
    gameState.level = gameState.level + 1
    if (gameState.level > 6) gameState.level = 1
    gameState.coinsGrid = []
    gameState.pathFinding = []

    createCoinsGrid()
    gameFrame()
    createPathFinding() 
    drawGhost()
    drawPlayer()

    setInterval(gameFrame, 100)
}

function gameFrame() {
    //console.log("tick")
    updateState()
    drawFrame()
}


function drawFrame() {
    ctx.clearRect(0, 0, 300, 250)
    drawWalls()
    drawCoins()
    drawGhost()
    drawTarget()
    drawPlayer()
}

function drawWalls() {
    const passages = levels[gameState.level]
    const columnsNum = levels.columns
    ctx.beginPath()
    for (let i = 0; i < passages.length; i++) {
        const x = i % columnsNum
        const y = Math.floor(i / columnsNum)
        ctx.fill()
        ctx.fillStyle = "blue"
        if (passages[i].indexOf(i + 1) == -1) {
            drawRight(x,y)
        }
        if (passages[i].indexOf(i + columnsNum) == -1) {
            drawBottom(x,y)
        }
    }
    ctx.fill()
    function drawBottom(x = 0, y = 0) {
        ctx.rect(x * 50, y * 50 + 50, 55, 5)
    }
    function drawRight(x = 0, y = 0) {
        ctx.rect(x * 50 + 50, y * 50, 5, 50)
    }
}

function drawCoins() {
    ctx.fillStyle = "yellow"
    ctx.fillStyle = "brown"
    gameState.coinsGrid.forEach(coin => {
        ctx.beginPath()
        ctx.arc(coin[0] * 25 + 25, coin[1] * 25 + 25, 4, 0, Math.PI * 2)
        ctx.fill()
    })
}

function drawGhost() {
    const img = assets.ghost
    const x = gameState.ghostPos[0] * 50 + 10
    const y = gameState.ghostPos[1] * 50 + 10
    ctx.drawImage(img, x, y)
    
    const img2 = assets.ghostError
    const x2 = gameState.erorrGhostPos[0] * 50 + 10
    const y2 = gameState.erorrGhostPos[1] * 50 + 10
    ctx.drawImage(img2, x2, y2)
}

function drawPlayer() {
    const img = assets.player
    const x = (gameState.player.cellIdx % 6) * 50 + gameState.player.offset[0] + 13
    const y = Math.floor(gameState.player.cellIdx / 6) * 50 + gameState.player.offset[1] + 12
    ctx.drawImage(img, x, y)
}

function drawTarget() {
    ctx.beginPath()
    ctx.fillStyle = "yellow"
    ctx.rect(gameState.player.pos[0] * 50, gameState.player.pos[1] * 50, 50, 50)
    ctx.fill()    
    ctx.fillStyle = "orange"
    ctx.beginPath()
    // ctx.arc(gameState.player.targetPos[0] * 50 + 21, gameState.player.targetPos[1] * 50 + 21, 4, 0, Math.PI * 2)
    ctx.rect(gameState.player.targetPos[0] * 50, gameState.player.targetPos[1] * 50, 50, 50)
    ctx.fill()    
}


function updateState() {
    // console.log(gameState.player)

    const dir = gameState.player.currentDirection
    const offset = gameState.player.offset
    const currCell = gameState.player.cellIdx
    const targetCell = gameState.player.targetCellIdx
    
    const passages = levels[gameState.level]

    // if (!(passages[gameState.player.cellIdx].indexOf(gameState.player.targetCellIdx) !== -1)) { // isMoveLegal but the new value
    //                 gameState.player.offset[0] = 0
    //                 gameState.player.targetCellIdx = gameState.player.currCell
    //                 gameState.player.targetPos[0] = gameState.player.pos[0] 
    // } 




    switch(dir) {
        case "ArrowRight":
            const isMoveLegal = passages[currCell].indexOf(targetCell) !== -1
            console.log(isMoveLegal, (passages[gameState.player.cellIdx].indexOf(gameState.player.cellIdx + 1) !== -1), gameState.player.targetCellIdx)
            if (offset[0] + 4 < 50 && isMoveLegal) {
                gameState.player.offset[0] = offset[0] + 4 
            } else if (offset[0] + 4 >= 50 && isMoveLegal) {
                gameState.player.offset[0] = offset[0] + 4 - 50
                gameState.player.cellIdx = currCell + 1
                gameState.player.targetCellIdx = currCell + 2
                gameState.player.pos[0] = gameState.player.pos[0] + 1
                gameState.player.targetPos[0] = gameState.player.targetPos[0] + 1
                if (!(passages[gameState.player.cellIdx].indexOf(gameState.player.targetCellIdx) !== -1)) { // isMoveLegal but the new value
                    gameState.player.offset[0] = 0
                    gameState.player.targetCellIdx = gameState.player.currCell
                    gameState.player.targetPos[0] = gameState.player.pos[0]
                } 
            }
        break
    }



 











    // const key = gameState.keyPressed
    // const ways = levels[gameState.level]
    // const currPos = gameState.playerPos
    // const currOff = gameState.playerOffset
    // const currCell = gameState.playerCellIdx
    // const currDir = gameState.currentDirection

    // let isMoveValid = undefined

    // switch (currDir) {
    //     case "ArrowLeft":
    //         currPos[0]
    //         // currOff[0] = currOff[0] - 4
    //     break
    //     case "ArrowRight":

    //         const nextOffX = currOff[0] + 4

    //         const goToNextCell = nextOffX % 50 < 4

    //         const rightCell = currCell + 1

    //         if (goToNextCell) {

    //             gameState.playerPos[0]

    //         } else {
    //             gameState.playerOffset[0] = nextOffX
    //         }
    //         // currOff[0] = currOff[0] + 4
    //     break
    //     case "ArrowUp":
    //         // currOff[1] = currOff[1] - 4
    //     break
    //     case "ArrowDown":
    //         // currOff[1] = currOff[1] + 4
    //     break
    // }
}

function createCoinsGrid() { // put a coin in every cell and on every passage
    const passages = levels[gameState.level]
    for (let i = 0; i < passages.length; i++) {
        let x = i % 6 * 2
        let y = Math.floor(i / 6) * 2
        gameState.coinsGrid.push([x,y])
        if (passages[i].indexOf(i + 1) !== -1) gameState.coinsGrid.push([x + 1, y])
        if (passages[i].indexOf(i + 6) !== -1) gameState.coinsGrid.push([x, y + 1])
    }
}

function createPathFinding() {
                        // const startTime = performance.now()
    const x = gameState.player.pos[0]
    const y = gameState.player.pos[1]
    const passages = levels[gameState.level]
    const columnsNum = levels.columns
    
    const distances = []
    const cellsUsed = []
    
    const root = y * levels.columns + x

    distances.push([root])
    cellsUsed.push(root)

    let temp = []
    while (cellsUsed.length < passages.length) {
        distances[distances.length - 1].forEach(cell => {
            passages[cell].forEach(way => {
                if (cellsUsed.indexOf(way) !== -1) return
                temp.push(way)
                cellsUsed.push(way)
            })
        }) 
        if (temp.length == 0) break
        distances.push(temp)
        temp = []
    }

    for (let i = 0; i < distances.length; i++) {
        const dist = i
        distances[i].forEach(cell => {
            gameState.pathFinding[cell] = dist
        })
    }
                        // const endTime = performance.now()
                        // console.log(`took ${endTime - startTime} milliseconds`)
    ctx.font = "20px Comic Sans MS";
    ctx.fillStyle = "white"
    for (let i = 0; i < distances.length; i++) {
        const dist = i
        distances[i].forEach(cell => {
            const x = cell % columnsNum
            const y = Math.floor(cell / columnsNum)
            ctx.fillText(`${i}`, x * 50 + 20, y * 50 + 30);
        })
    }

}

function drawCellsNumbers() {
    const passages = levels[gameState.level]
    const columnsNum = levels.columns

    for (let i = 0; i < passages.length; i++) {
        const x = i % columnsNum
        const y = Math.floor(i / columnsNum)
        ctx.font = "20px Comic Sans MS"
        ctx.fillStyle = "white"
        ctx.fillText(`${i}`, x * 50 + 20, y * 50 + 30)
    }
    //ctx.fill()
}

function updateControls(e) {
    if (e.key !== gameState.player.currentDirection) {
        gameState.player.currentDirection = e.key
        const passages = levels[gameState.level] 
        const currCell = gameState.player.cellIdx
        let targetCell = currCell
        if (e.key === "ArrowRight") {
            console.log('right')
            targetCell = currCell + 1
            console.log("keys: ",targetCell)
            console.log(passages[currCell].indexOf(targetCell))
            if (passages[currCell].indexOf(targetCell) !== -1) {
                console.log('right in')
                gameState.player.targetCellIdx = targetCell
                gameState.player.targetPos[0] = targetCell % 6
                gameState.player.targetPos[1] = Math.floor(targetCell / 6)
            }
        } else if (e.key === "ArrowLeft") {
            targetCell = currCell - 1
            if (passages[currCell].indexOf(targetCell) !== -1) {
                gameState.player.targetCellIdx = targetCell
                gameState.player.targetPos[0] = targetCell % 6
                gameState.player.targetPos[1] = Math.floor(targetCell / 6)
            }
        } else if (e.key === "ArrowUp") {
            targetCell = currCell - 6 
            if (passages[currCell].indexOf(targetCell) !== -1) {
                gameState.player.targetCellIdx = targetCell
                gameState.player.targetPos[0] = targetCell % 6
                gameState.player.targetPos[1] = Math.floor(targetCell / 6)
            } 
        } else if (e.key === "ArrowDown") {
            targetCell = currCell + 6
            console.log(passages[currCell].indexOf(targetCell))
            if (passages[currCell].indexOf(targetCell) !== -1) {
                console.log("asdf1")
                gameState.player.targetCellIdx = targetCell
                gameState.player.targetPos[0] = targetCell % 6
                gameState.player.targetPos[1] = Math.floor(targetCell / 6)
            }
        }        
    }
    drawFrame()
}

document.addEventListener("keydown", updateControls)

    </script>
</body>
</html>
